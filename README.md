.h documentation:

1) "enum devectorBufferState" is majorly a return value which tells whether the buffer state is valid or invalid (which can only be a consequence of resize failure(MEMORY_LIMIT_REACHED)).
2) "struct devector" is the data structure and comprises of 5 struct fields: buffer holds the memory address of the space where data is written, elem_size is the sizeof(element) which gets written to buffer, and capacity is (as suggested by the name) the capacity of buffer (the unit of capacity is elem_size and (capacity * elem_size) is the actualy size of space (in bytes) occupied by the buffer). At last, the head and tail fields are the insertion points for front and back elements respectively. But there is one important thing to notice that head is the index that is calculated from the end and tail is index calculated from the start of circular buffer.
3) size() returns the current number of elements in the buffer.
4) at() returns the address of the ith index element (we are talking about a conceptual ith index (which is determined by the order in which we performed push and pop operations), not the actual ith index of buffer)
5) push() and pop() functions for front and back are the reason I am writing this great piece of literature and the reason you reading it. I am sure I don't need to explain a thing about them.
6) deploy() is the constructor and destroy() is the destructor. They together serve as the opening and closing of this great ceremony.

.c documentation:

1) Before diving into .c, I want you to understand the two kinds of data representation in circular buffer: contiguous and wrap-around. contiguous case: [O] [front] [E] [back] [O] & wrap-around case: [E] [back] [O] [front] [E] (where [E] represents a sub-array of elements and [O] represents a sub-array of 0s).
2) The third case is when the front meets the back. This can also be handled as a wrap-around case.
3) (front, back) = (capacity - 1 - head, tail).
4) Now notice that front is not where the last front element was, front is where the next front element would be inserted. Same is the case with back. That's what I meant by "insertion points" in .h documentation (point 2), explaining head and tail fields.
5) level-wise traversal of the dependency tree of functions can be shown as: (resize)<-(advance, retreat)<-(push front & back, pop front and back).
6) size is then (tail + head) % capacity because in wrap-around case, head indicates the count of elements on the right of [O] and tail is the count of elements on the left of [O], and this is when head + tail < capacity (because front > back in wrap-around, which means capacity - 1 - head > tail which means that head + tail < capacity - 1 in wrap around case). Then size is head + tail - capacity in the contiguous case because size = back - (front + 1) = tail - capacity + head = head + tail - capacity there and this is the case when head + tail >= capacity (because front < back in contiguous, which means that capacity - 1 - head < tail which means that head + tail > capacity - 1 which means that head + tail >= capacity). we can write those cases combined as (head + tail) % capacity.
7) at function is actually quite easier to reason about. the ith conceptual index means the (capacity - head + i) buffer index because (capacity - head) is (front + 1) and in both contiguous and wrap around cases, we can do (front + 1 + i) % capacity and that would give us the address of ith conceptual index. Notice that we are treating front + 1 as a base because front is the point of insertion and so front + 1 is the actual front element.
8) resize is pretty simple once you understand the 3 cases of data representations. 
9) All other functions are trivial, once you truly understand the details that are given above, but I want to pause and explain MIN_CAPACITY and INITIAL CAPACITY, and I could explain them only after transfering my whole mental model to you. MIN_CAPACITY is the minimum capacity of buffer and it's 2 becase front and back count to 2. These two markers need a separate space of 2 to exist because I am treating them as entities. and when they collide each other that's the condition of resize to expand.
10) Now it might seem odd to you that I am not checking capacity before pushing a value, and that's because INITAL_CAPACITY >= MIN_CAPACITY (library defined), and so I always have enough space to start the procedure. And so I just check for resize conditions after pushing the value. So, I always have free space in the memory, and the only time I don't have it is when the system doesn't have more memory.
11) There is another reason that INITIAL_CAPACITY is library defined rather that being used defined and that is that INITIAL_CAPACITY is cleaner being a power of 2 i.e. INITIAL CAPACITY = 2^k, k >= 1 because that way it grows to be a power of 2 and it shrinks to be a power of 2 and that symmetry is really very comfortable while reasoning about the growth and shrinking system.
